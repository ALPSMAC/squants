{"name":"Squants","tagline":"The Scala API for Quantities, Units of Measure and Dimensional Analysis","body":"Squants is a framework of data types and a domain specific language (DSL) for representing Quantities,\r\ntheir Units of Measure, and their Dimensional relationships.\r\nThe API supports typesafe dimensional analysis, improved domain models and more.\r\nAll types are immutable and thread-safe.\r\n\r\n[GitHub](https://github.com/garyKeorkunian/squants)\r\n|\r\n[User Forum](https://groups.google.com/forum/#!forum/squants)\r\n|\r\n[Wiki](https://github.com/garyKeorkunian/squants/wiki)\r\n\r\n### Current Versions\r\nCurrent Release: **0.4.2**\r\n([API Docs](https://oss.sonatype.org/service/local/repositories/releases/archive/com/squants/squants_2.11/0.4.2/squants_2.11-0.4.2-javadoc.jar/!/index.html#squants.package))\r\n\r\nDevelopment Build: **0.5.1-SNAPSHOT**\r\n([API Docs](https://oss.sonatype.org/service/local/repositories/snapshots/archive/com/squants/squants_2.11/0.5.1-SNAPSHOT/squants_2.11-0.5.1-SNAPSHOT-javadoc.jar/!/index.html#squants.package))\r\n\r\n[Release History](https://github.com/garyKeorkunian/squants/wiki/Release-History)\r\n\r\n[![Build Status](https://travis-ci.org/garyKeorkunian/squants.png?branch=master)](https://travis-ci.org/garyKeorkunian/squants)\r\n\r\n## Installation\r\nRepository hosting for Squants is provided by Sonatype.\r\nTo use Squants in your SBT project you will need to add the following dependency to your build.\r\n\r\n    \"com.squants\"  %% \"squants\"  % \"0.4.2\"\r\nor\r\n\r\n    \"com.squants\"  %% \"squants\"  % \"0.5.1-SNAPSHOT\"\r\n\r\n\r\nTo use Squants in your Maven project add the following depencency to your\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.squants</groupId>\r\n    <artifactId>squants_2.11</artifactId>\r\n    <version>0.4.2</version>\r\n</dependency>\r\n```\r\n\r\nBeginning with Squants 0.4 series, both Scala 2.10 and 2.11 builds are available.\r\n\r\nTo use Squants interactively in the Scala REPL, clone the git repo and run `sbt console`\r\n\r\n    git clone https://github.com/garyKeorkunian/squants\r\n    cd squants\r\n    sbt console\r\n\r\n## Better Dimensional Analysis\r\n*The Trouble with Doubles*\r\n\r\nWhen building programs that perform dimensional analysis, developers are quick to declare\r\nquantities using a basic numeric type, usually Double.  While this may be satisfactory in some situations,\r\nit can often lead to semantic and other logic issues.\r\n\r\nFor example, when using a Double to describe quantities of Energy (kWh) and Power (kW), it is possible\r\nto compile a program that adds these two values together.  This is not appropriate as kW and kWh\r\nmeasure quantities of two different dimensions.  The unit kWh is used to measure an amount of Energy used\r\nor produced.  The unit kW is used to measure Power/Load, the rate at which Energy is being used\r\nor produced, that is, Power is the first time derivative of Energy.\r\n\r\n*Power = Energy / Time*\r\n\r\nConsider the following code\r\n\r\n```scala\r\nval loadKw: Double = 1.2\r\nval energyMwh: Double = 24.2\r\nval sumKw = loadKw + energyMwh\r\n```\r\n\r\nwhich not only adds quantities of different dimensions (Power vs Energy),\r\nit also fails to convert the scales implied in the val names (Mega vs Kilo).\r\nBecause this code compiles, detection of these errors is pushed further into the development cycle.\r\n\r\n### Dimensional Type Safety\r\n\r\n_Only quantities with the same dimensions may be compared, equated, added, or subtracted._\r\n\r\nSquants helps prevent errors like these by type checking operations at compile time and\r\nautomatically applying scale and type conversions at run-time.  For example,\r\n\r\n```scala\r\nval load1: Power = Kilowatts(12)\r\nval load2: Power = Megawatts(0.023)\r\nval sum = load1 + load2\r\nsum should be(Kilowatts(35))\r\nsum should be(Megawatts(0.035))\r\n```\r\n\r\nis a valid assertion because Kilowatts and Megawatts are both units of Power.  Only the scale is\r\ndifferent and the library applies an appropriate conversion.  Also, notice that keeping track of\r\nthe scale within the value name is no longer needed.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1.2)\r\nval energy: Energy = KilowattHours(23.0)\r\nval sum = load + energy // Invalid operation - does not compile\r\n```\r\nThe unsupported operation in this expression prevents the code from compiling,\r\ncatching the error made when using Double in the example above.\r\n\r\n### Dimensionally Correct Type Conversions\r\n\r\n_One may take ratios of quantities with different dimensions, and multiply or divide them._\r\n\r\nDimensionally correct type conversions are a key feature of Squants.\r\nConversions are implemented by defining relationships between Quantity types using the * and / operators.\r\n\r\nThe following code demonstrates creating ratio between two quantities of the same dimension:\r\n\r\n```scala\r\nval ratio: Double = Days(1) / Hours(3)\r\nratio should be(8.0)\r\n```\r\n\r\nThis code demonstrates use of Power's `*` method that takes a Time and returns an Energy:\r\n\r\n```scala\r\nval load: Power = Kilowatts(1.2)\r\nval time: Time = Hours(2)\r\nval energyUsed: Energy = load * time\r\nenergyUsed should be(KilowattHours(2.4))\r\n```\r\n\r\nThis code demonstrates use of Energy's `/` method that takes a Time and returns a Power:\r\n\r\n```scala\r\nval aveLoad: Power = energyUsed / time\r\naveLoad should be(Kilowatts(1.2)\r\n```\r\n\r\n### Unit Conversions\r\nIf necessary, the value can be extracted in the desired unit with the `to` method.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1200)\r\nval mw: Double = load to Kilowatts // returns 1200.0 (default method)\r\nval gw: Double = load to Gigawatts // returns 0.0012\r\nval my: Double = load to MyPowerUnit // returns ??? Whatever you want\r\nval kw: Double = load toKilowatts // returns 1200.0 (convenience method)\r\n```\r\n\r\nStrings formatted in the desired unit is also supported\r\n\r\n```scala\r\nval kw: String = load toString Kilowatts // returns “1200.0 kW”\r\nval mw: String = load toString Megawatts // returns “1.2 MW”\r\nval gw: String = load toString Gigawatts // returns “0.0012 GW”\r\n```\r\n\r\nSimple console based conversions (using DSL described below)\r\n\r\n```scala\r\n1.kilograms to Pounds       // returns 2.2046226218487757\r\n2.1.pounds to Kilograms     // returns 0.952543977\r\n100.C to Fahrenheit         // returns 212.0\r\n```\r\n\r\n### Approximations\r\nCreate an implicit Quantity value to be used as a tolerance in approximate equality comparisons.\r\nUse the `approx` method (`=~`, `~=`, `≈` operator) like the `equals` method (`==` operator)\r\n\r\n```scala\r\nimplicit val tolerance = Watts(.1)\r\nval load = Kilowatts(2.0)\r\nval reading = Kilowatts(1.9999)\r\n\r\n // uses implicit tolerance\r\nload =~ reading should be(true)\r\nload ≈ reading should be(true)\r\nload approx reading should be(true)\r\n```\r\n\r\nThe `=~` and `≈` are the preferred operators as they have the correct precedence for equality operations.\r\nThe `~=` is provided for those who wish to use a more natural looking approx operator using standard characters.\r\nHowever, because of its lower precedence, user code may require parenthesis around these comparisons\r\n\r\n### Vectors\r\n\r\nAll Quantity types in Squants represent the scalar value of a quantity.\r\nThat is, there is no direction information encoded in any of the Quantity types.\r\nThis is true even for Quantities which are normally vector quantities (ie. Velocity, Acceleration, etc).\r\n\r\nVector quantities in Squants are implemented as a case class that takes a variable parameter list of like quantities\r\nrepresenting a set of point coordinates in Cartesian space.\r\nThe dimensionality of the vector is determined by the number of arguments.\r\nMost basic vector operations are currently supported (addition, subtraction, scaling, cross and dot products)\r\n\r\n```scala\r\nval vector = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3)\r\nval magnitude: Length = vector.magnitude        // returns the scalar value of the vector\r\nval normalized = vector.normalize(Kilometers)   // returns a corresponding vector scaled to 1 of the given unit\r\n\r\nval vector2 = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3)\r\nval vectorSum = vector + vector2        // returns the sum of two vectors\r\nval vectorDiff = vector - vector2       // return the difference of two vectors\r\nval vectorScaled = vector * 5           // returns vector scaled 5 times\r\nval vectorReduced = vector / 5          // returns vector reduced 5 time\r\nval vectorDouble = vector / 5.meters    // returns vector reduced and converted to DoubleVector\r\nval dotProduct = vector * vectorDouble  // returns the Dot Product of vector and vectorDouble\r\n\r\nval crossProduct = vector crossProduct vectorDouble  // currently only supported for 3-dimensional vectors\r\n```\r\n\r\nDimensional conversions within Vector operations.\r\nThis feature is currently under development and the final implementation being evaluated.\r\nThis following type of operation is the goal.\r\n\r\n```scala\r\nval vectorLength = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3)\r\nval vectorArea: QuantityVector[Area] = vectorLength * Kilometers(10)\r\nval vectorVelocity: QuantityVector[Velocity] = vectorLength / Seconds(1)\r\n```\r\n\r\nSimple non-quantity (Double based) vectors are also supported\r\n\r\n```scala\r\nval vector = DoubleVector(1.2, 4.3, 2.3, 5.4)   // a Four-dimensional vector\r\n```\r\n\r\n## Market Package\r\nMarket Types are similar but not quite the same as other quantities in the library.\r\nThe primary type, Money, is derived from Quantity, and its Units of Measure are Currencies.\r\nHowever, because the conversion multipliers between units can not be predefined,\r\nmany of the behaviors have been overridden and augmented to realize correct behavior.\r\n\r\n### Money\r\nA Quantity of purchasing power measured in units we call Currencies.\r\nCreate Money values using standard Currency codes.\r\n\r\n```scala\r\nval tenBucks: Money = USD(10)\r\nval someYen: Money = JPY(1200)\r\nval goldStash: Money = XAU(50)\r\nval digitalStash: Money = BTC(50)\r\n```\r\n\r\n### Price\r\nA Ratio between Money and another Quantity.\r\nA Price value is typed on a Quantity and can be denominated in any defined Currency.\r\n\r\n*Price = Money / Quantity*\r\n\r\n```scala\r\nval threeForADollar: Price[Dimensionless] = USD(1) / Each(3)\r\nval energyPrice: Price[Energy] = USD(102.20) / MegawattHours(1)\r\nval milkPrice: Price[Volume] = USD(4) / UsGallons(1)\r\n\r\nval costForABunch: Money = threeForADollar * Dozen(10) // returns USD(40)\r\nval energyCost: Money = energyPrice * MegawattHours(4) // returns USD(408.80)\r\nval milkQuota: Volume = milkPrice * USD(20) // returns UsGallons(5)\r\n```\r\n\r\n### FX Support\r\nCurrency Exchange Rates\r\n\r\n```scala\r\n// create an exchange rate\r\nval rate = CurrencyExchangeRate(USD(1), JPY(100))\r\n// OR\r\nval rate = USD / JPY(100)\r\n// OR\r\nval rate = JPY(100) -> USD(1)\r\n// OR\r\nval rate = JPY(100) toThe USD(1)\r\n\r\nval someYen: Money = JPY(350)\r\nval someBucks: Money = USD(23.50)\r\n\r\n// Use the convert method which automatically converts the money to the 'other' currency\r\nval dollarAmount: Money = rate.convert(someYen) // returns USD(3.5)\r\nval yenAmount: Money = rate.convert(someBucks)  // returns JPY(2350)\r\n\r\n// or just use the * operator in either direction (money * rate, or rate * money)\r\nval dollarAmount2: Money = rate * someYen       // returns USD(3.5)\r\nval yenAmount2: Money = someBucks * rate\t\t// returns JPY(2350)\r\n```\r\n\r\n### Money Context\r\nA MoneyContext can be implicitly declared to define default settings and applicable exchange rates within its scope.\r\nThis allows your application to work with a default currency based on an application configuration or other dynamic source.\r\nIt also provides support for updating exchange rates and using those rates for automatic conversions between currencies.\r\nThe technique and frequency chosen for exchange rate updates is completely in control of the application.\r\n\r\n```scala\r\nval exchangeRates = List(USD / CAD(1.05), USD / MXN(12.50), USD / JPY(100))\r\nimplicit val moneyContext = defaultMoneyContext withExchangeRates exchangeRates\r\n\r\nval someMoney = Money(350) // 350 in the default Cur\r\nval usdMoney: Money = someMoney in USD\r\nval usdBigDecimal: BigDecimal = someMoney to USD\r\nval yenCost: Money = (energyPrice * MegawattHours(5)) in JPY\r\nval northAmericanSales: Money = (CAD(275) + USD(350) + MXN(290)) in USD\r\n```\r\n\r\n## Quantity Ranges\r\nUsed to represent a range of Quantity values between an upper and lower bound\r\n\r\n```scala\r\nval load1: Power = Kilowatts(1000)\r\nval load2: Power = Kilowatts(5000)\r\nval range: QuantityRange[Power] = QuantityRange(load1, load2)\r\n```\r\nUse multiplication and division to create a Seq of ranges from the original\r\n\r\n```scala\r\n// Create a Seq of 10 sequential ranges starting with the original and each the same size as the original\r\nval rs1 = range * 10\r\n// Create a Seq of 10 sequential ranges each 1/10th of the original size\r\nval rs2 = range / 10\r\n// Create a Seq of 10 sequential ranges each with a size of 400 kilowatts\r\nval rs3 = range / Kilowatts(400)\r\n```\r\nApply foreach, map and foldLeft/foldRight directly to QuantityRanges with a divisor\r\n\r\n```scala\r\n// foreach over each of the 400 kilometer ranges within the range\r\nrange.foreach(Kilometers(400)) {r => ???}\r\n// map over each of 10 even parts of the range\r\nrange.map(10) {r => ???}\r\n// fold over each 10 even parts of the range\r\nrange.foldLeft(10)(0) {(z, r) => ???}\r\n```\r\n\r\n## Natural Language Features\r\nImplicit conversions give the DSL some features that allows user code to express quantities in a\r\nmore naturally expressive and readable way.\r\n\r\nCreate Quantities using Unit Of Measure Factory objects (no implicits required)\r\n\r\n```scala\r\nval load = Kilowatts(100)\r\nval time = Hours(3.75)\r\nval money = USD(112.50)\r\nval price = Price(money, MegawattHours(1))\r\n```\r\n\r\nCreate Quantities using Unit of Measure names and/or symbols (uses implicits)\r\n\r\n```scala\r\nval load1 = 100 kW \t\t\t        // Simple expressions don’t need dots\r\nval load2 = 100 megaWatts\r\nval time = 3.hours + 45.minutes     // Compound expressions may need dots\r\n```\r\n\r\nCreate Quantities using operations between other Quantities\r\n\r\n```scala\r\nval energyUsed = 100.kilowatts * (3.hours + 45.minutes)\r\nval price = 112.50.USD / 1.megawattHours\r\nval speed = 55.miles / 1.hours\r\n```\r\n\r\nCreate Quantities using formatted Strings\r\n\r\n```scala\r\nval load = Power(\"40 MW\")\t\t// 40 MW\r\n```\r\n\r\nUse single unit values to simplify expressions\r\n\r\n```scala\r\n// Hours(1) == 1.hours == hour\r\nval ramp = 100.kilowatts / hour\r\nval speed = 100.kilometers / hour\r\n\r\n// MegawattHours(1) == 1.megawattHours == megawattHour == MWh\r\nval hi = 100.dollars / MWh\r\nval low = 40.dollars / megawattHour\r\n```\r\n\r\nImplicit conversion support for using Double on the left side of operations\r\n\r\n```scala\r\nval price = 10 / dollar\t    // 1 USD / 10 ea\r\nval freq = 60 / second\t    // 60 Hz\r\nval load = 10 * 4.MW\t\t// 40 MW\r\n```\r\n\r\nCreate Quantity Ranges using `to` or `plusOrMinus` (`+-`) operators\r\n\r\n```scala\r\nval range1 = 1000.kW to 5000.kW\t    // 1000.kW to 5000.kW\r\nval range2 = 5000.kW +- 1000.kW     // 4000.kW to 6000.kW\r\n```\r\n\r\n### Numeric Support\r\nMost Quantities that support implicit conversions also include an implicit Numeric object that can be imported\r\nto your code where Numeric support is required.  These follow the following pattern:\r\n\r\n```scala\r\nimport squants.mass.MassConversions.MassNumeric\r\n\r\nval sum = List(Kilograms(100), Grams(34510)).sum\r\n```\r\n\r\nThe MoneyNumeric implementation is a bit different than the implementations for other quantity types\r\nin a few important ways.\r\n\r\n1. MoneyNumeric is a class, not an object like the others.\r\n2. To create a MoneyNumeric value there must be an implicit MoneyContext in scope.\r\n3. The MoneyContext must contain applicable exchange rates if you will be applying cross-currency Numeric ops.\r\n\r\nThe following code provides a basic example for creating a MoneyNumeric:\r\n\r\n```scala\r\nimport MoneyConversions._\r\nimplicit val moneyContext = defaultMoneyContext\r\nimplicit val moneyNum = new MoneyNumeric()\r\n\r\nval sum = List(USD(100), USD(10)).sum\r\n```\r\n\r\n## Type Hierarchy\r\nThe type hierarchy includes two root base traits:  Quantity and UnitOfMeasure\r\n\r\n### Quantity\r\nQuantity measures the magnitude or multitude of some thing.  Classes extending Quantity represent the\r\nvarious types of quantities that can be measured.  These are our alternatives to just using Double.\r\nCommon 'Base' Quantities include Mass, Temperature, Length, Time, Energy, etc.\r\n\r\nDerived Quantities are based on one or more other quantities.  Typical examples include Time Derivatives.\r\n\r\nSpeed is the 1st Time Derivative of Length (Distance), Acceleration is the 2nd Time Derivative.\r\n\r\n```scala\r\nval distance: Length = Kilometers(100)\r\nval time: Time = Hours(2)\r\nval speed: Speed = distance / time\r\nspeed.toKilometersPerHour should be(50.0)\r\nval acc: Acceleration = Meters(50) / Second(1) / Second(1)\r\nacc.toMetersPerSecondSquared should be(50)\r\n```\r\nPower is the 1st Time Derivative of Energy, PowerRamp is the 2nd\r\n\r\n```scala\r\nval energy: Energy = KilowattHours(100)\r\nval time: Time = Hours(2)\r\nval power: Power = energy / time\r\npower.toKilowatts should be(50.0)\r\nval ramp: PowerRamp = KilowattHours(50) / Hours(1) / Hours(1)\r\nramp.toKilowattsPerHour should be(50)\r\n```\r\n\r\nSquants currently supports over 50 quantity types.\r\n\r\n### Unit of Measure\r\nUnitOfMeasure is the scale or multiplier in which the Quantity is being measured.\r\n\r\nFor each Quantity a series of UOM objects implement a base UOM trait typed to that Quantity.\r\nThe UOM objects define the unit symbols and conversion settings.\r\nFactory methods in each UOM object create instances of the corresponding Quantity.\r\n\r\nFor example UOM objects extending LengthUnit can be used to create Length quantities\r\n\r\n```scala\r\nval len1: Length = Inches(5)\r\nval len2: Length = Meters(4.3)\r\nval len3: Length = UsMiles(345.2)\r\n```\r\nUnits of Measure for Time include Milliseconds, Seconds, Minutes, Hours, and Days\r\n\r\nUnits of Measure for Temperature include Celsius, Kelvin, and Fahrenheit\r\n\r\nUnits of Measure for Mass include Grams, Kilograms, etc.\r\n\r\nSquants currently supports over 150 units of measure\r\n\r\n## Use Cases\r\n\r\n### Dimensional Analysis\r\n\r\nThe primary use case for Squants, as described above, is to produce code that is typesafe with in domains\r\nthat perform dimensional analysis.\r\n\r\n```scala\r\nval energyPrice: Price[Energy] = 45.25.money / megawattHour\r\nval energyUsage: Energy = 345.kilowatts * 5.4.hours\r\nval energyCost: Money = energyPrice * energyUsage\r\n\r\nval dodgeViper: Acceleration = 60.miles / hour / 3.9.seconds\r\nval speedAfter5Seconds: Velocity = dodgeViper * 5.seconds\r\nval timeTo100MPH: Time = 100.miles / hour / dodgeViper\r\n\r\nval density: Density = 1200.kilograms / cubicMeter\r\nval volFlowRate: VolumeFlowRate = 10.gallons / minute\r\nval flowTime: Time = 30.minutes\r\nval totalMassFlow: Mass = volFlowRate * flowTime * density\r\n```\r\n\r\n### Domain Modeling\r\nAnother excellent use case for Squants is stronger types for fields in your domain model.\r\nThis is OK ...\r\n\r\n```scala\r\ncase class Generator(id: String, maxLoadKW: Double, rampRateKWph: Double,\r\noperatingCostPerMWh: Double, currency: String, maintenanceTimeHours: Double)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5000, 7500, 75.4, \"USD\", 1.5)\r\nval gen2 = Generator(\"Gen2\", 100, 250, 2944.5, \"JPY\", 0.5)\r\nassetManagementActor ! ManageGenerator(gen1)\r\n```\r\n… but this is much better\r\n\r\n```scala\r\ncase class Generator(id: String, maxLoad: Power, rampRate: PowerRamp,\r\noperatingCost: Price[Energy], maintenanceTime: Time)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5 MW, 7.5.MW/hour, 75.4.USD/MWh, 1.5 hours)\r\nval gen2 = Generator(\"Gen2\", 100 kW, 250 kWph, 2944.5.JPY/MWh, 30 minutes)\r\nassetManagementActor ! ManageGenerator(gen1)\r\n```\r\n\r\n### Anticorruption Layers\r\n\r\nCreate wrappers around external services that use basic types to represent quantities.\r\nYour application code then uses the ACL to communicate with that system thus eliminating the need to deal\r\nwith type and scale conversions in your application logic.\r\n\r\n```scala\r\nclass ScadaServiceAnticorruption(val service: ScadaService) {\r\n  // ScadaService returns load as Double representing Megawatts\r\n  def getLoad: Power = Megawatts(service.getLoad(meterId))\r\n  }\r\n  // ScadaService.sendTempBias requires a Double representing Fahrenheit\r\n  def sendTempBias(temp: Temperature) =\r\n    service.sendTempBias(temp.to(Fahrenheit))\r\n}\r\n```\r\n\r\nImplement the ACL as a trait and mix in to the application's services where needed.\r\n\r\n```scala\r\ntrait WeatherServiceAntiCorruption {\r\n  val service: WeatherService\r\n  def getTemperature: Temperature = Celsius(service.getTemperature)\r\n  def getIrradiance: Irradiance = WattsPerSquareMeter(service.getIrradiance)\r\n}\r\n```\r\n\r\nExtend the pattern to provide multi-currency support\r\n\r\n```scala\r\nclass MarketServiceAnticorruption(val service: MarketService)\r\n     (implicit val moneyContext: = MoneyContext) {\r\n  // MarketService.getPrice returns a Double representing $/MegawattHour\r\n  def getPrice: Price[Energy] =\r\n    (USD(service.getPrice) in moneyContext.defaultCurrency) / megawattHour\r\n  // MarketService.sendBid requires a Double representing $/MegawattHour\r\n  // and another Double representing the max amount of energy in MegawattHours\r\n  def sendBid(bid: Price[Energy], limit: Energy) =\r\n    service.sendBid((bid * megawattHour) to USD, limit to MegawattHours)\r\n}\r\n```\r\n\r\nBuild Anticorruption into Akka routers\r\n\r\n```scala\r\n// LoadReading message used within a Squants enabled application context\r\ncase class LoadReading(meterId: String, time: Long, load: Power)\r\nclass ScadaLoadListener(router: Router) extends Actor {\r\n  def receive = {\r\n   // ScadaLoadReading - from an external service - sends load as a string\r\n   // eg, “10.3 MW”, “345 kW”\r\n   case msg @ ScadaLoadReading(meterId, time, loadString) ⇒\r\n    // Parse the string and on success emit the Squants enabled event to routees\r\n    Power(loadString) match {\r\n      case Success(p) => router.route(LoadReading(meterId, time, p), sender())\r\n      case Failure(e) => // react to QuantityStringParseException\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n... and REST API's with contracts that require basic types\r\n\r\n```scala\r\ntrait LoadRoute extends HttpService {\r\n  def repo: LoadRepository\r\n  val loadRoute = {\r\n    path(\"meter-reading\") {\r\n      // REST API contract requires load value and units in different fields\r\n      // Units are string values that may be 'kW' or 'MW'\r\n      post {\r\n        parameters(meterId, time, loadDouble, unit) { (meterId, time, loadDouble, unit) =>\r\n          complete {\r\n            val load = unit match {\r\n              case \"kW\" => Kilowatts(loadDouble)\r\n              case \"MW\" => Megawatts(loadDouble)\r\n            }\r\n            repo.saveLoad(meterId, time, load)\r\n          }\r\n        }\r\n      } ~\r\n      // REST API contract requires load returned as a number representing megawatts\r\n      get {\r\n        parameters(meterId, time) { (meterId, time) =>\r\n          complete {\r\n            repo.getLoad(meterId, time) to Megawatts\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Caveats\r\n\r\nCode is offered as-is, with no implied warranty of any kind.\r\nComments, criticisms, and/or praise are welcome, especially from scientists, engineers and the like.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}