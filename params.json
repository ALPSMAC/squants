{"name":"Squants","tagline":"The Scala API for Quantities, Units of Measure and Dimensional Analysis","body":"[![Build Status](https://travis-ci.org/garyKeorkunian/squants.png?branch=master)](https://travis-ci.org/garyKeorkunian/squants)\r\n\r\nView the API Documentation [here](http://www.squants.com/target/scala-2.10/api/#squants.package)\r\n\r\n## Installation\r\nBuild and install to your local Ivy cache with sbt publish-local (requires sbt 0.13).\r\n\r\n    git clone https://github.com/garyKeorkunian/squants\r\n    cd squants\r\n    sbt publish-local\r\n\r\nAdd squants to your sbt project dependencies\r\n\r\n    libraryDependencies += \"com.github.garyKeorkunian\" %% \"squants\" % \"0.1-SNAPSHOT\"\r\n\r\n## Overview\r\nSquants is a framework of data types and a domain specific language (DSL) for representing Quantities,\r\ntheir Units of Measure, and their Dimensional relationships.\r\nThe API supports typesafe dimensional analysis, improved domain models and more.\r\nAll types are immutable and thread-safe.\r\n\r\n## Better Dimensional Analysis\r\n*The Trouble with Doubles*\r\n\r\nWhen using a Double to describe Energy (kWh) and Power (kW), it is possible\r\nto compile a program that adds these two values together.  This is not appropriate as kW and kWh\r\nmeasure two different quantities.  The unit kWh is used to measure an amount of Energy used\r\nor produced.  The unit kW is used to measure Power/Load, the rate at which Energy is being used\r\nor produced, that is, Power is the first time derivative of Energy; Power = Energy / Time.\r\n\r\nConsider the following code\r\n```scala\r\nval loadKw: Double = 1.2\r\nval energyMwh: Double = 24.2\r\nval sumKw = loadKw + energyMwh\r\n```\r\nwhich not only adds different quantity types (load vs energy), it also fails to convert the scales (Mega vs Kilo).\r\nBecause this code compiles, detection of these errors is pushed further into the development cycle.\r\n\r\n### Dimensional Types\r\nThe Squants Type Library and DSL helps prevent errors like these by type checking operations at compile time and\r\nautomatically applying scale and type conversions (see below) at run-time.  For example,\r\n```scala\r\nval load1: Power = Kilowatts(12)\r\nval load2: Power = Megawatts(0.023)\r\nval sum = load1 + load2\r\nassert(sum == Kilowatts(35))\r\nassert(sum == Megawatts(0.035))\r\n```\r\nis a valid assertion because Kilowatts and Megawatts are both measures of load.  Only the scale is\r\ndifferent and the framework applies an appropriate conversion.  Also, notice that keeping track of\r\nthe scale within the value name is no longer needed.\r\n\r\n### Dimensional Type Safety\r\nThe following code highlights the type safety features.\r\n```scala\r\nval load: Power = Kilowatts(1.2)\r\nval energy: Energy = KilowattHours(23.0)\r\nval sum = load + energy // Invalid operation - does not compile\r\n```\r\nThe invalid expression prevents the code from compiling, catching the error made when using Double above.\r\n\r\n### Smart Type Conversions\r\nDimensionally smart type conversions are a key feature of Squants.\r\nMost conversions are implemented by defining relationships between Quantity types using infix operations.\r\n```scala\r\nval load: Power = Kilowatts(1.2)\r\nval time: Time = Hours(2)\r\nval energyUsed: Energy = load * time\r\nassert(energyUsed == KilowattHours(2.4))\r\n```\r\nThis code demonstrates use of the Power.* method, defined as an infix operator that takes a Time\r\nvalue and returns an Energy value, conversely\r\n```scala\r\nval aveLoad: Power = energyUsed / time\r\nassert(aveLoad == Kilowatts(1.2)\r\n```\r\ndemonstrates use of the Energy./ method that takes a Time and returns a Power\r\n\r\n### Unit Conversions\r\nIf necessary, the value in the desired unit can be extracted with the\r\nthe `to` method.\r\n```scala\r\nval load: Power = Kilowatts(1200)\r\nval mw: Double = load to Kilowatts // returns 1200.0 (default method)\r\nval gw: Double = load to Gigawatts // returns 0.0012\r\nval my: Double = load to MyPowerUnit // returns ??? Whatever you want\r\nval kw: Double = load toKilowatts // returns 1200.0 (convenience method)\r\n```\r\nStrings formatted in the desired unit is also supported\r\n```scala\r\nval kw: String = load toString Kilowatts // returns “1200.0 kW”\r\nval mw: String = load toString Megawatts // returns “1.2 MW”\r\nval gw: String = load toString Gigawatts // returns “0.0012 GW”\r\n```\r\n\r\n## Market Package\r\nMarket Types are similar but not quite the same as other quantities in the library.\r\nThe primary type, Money, is derived from Quantity, and its Units of Measure are Currencies.\r\nHowever, because the conversion multipliers between units can not be predefined, many of the behaviors have been\r\noverridden and augmented to realize correct behavior.\r\n\r\n### Money\r\nA Quantity of purchasing power\r\n```scala\r\nval tenBucks: Money = USD(10)\r\nval someYen: Money = JPY(1200)\r\nval goldStash: Money = XAU(50)\r\nval digitalStash: Money = BTC(50)\r\n```\r\n\r\n### Price\r\nA Ratio between Money and another Quantity\r\n```scala\r\nval threeForADollar: Price[Count] = USD(1) / Each(3)\r\nval energyPrice: Price[Energy] = USD(102.20) / MegawattHours(1)\r\nval milkPrice: Price[Volume] = USD(4) / UsGallons(1)\r\n\r\nval costForABunch: Money = threeForADollar * Dozen(10) // returns USD(40)\r\nval energyCost: Money = energyPrice * MegawattHours(4) // returns USD(408.80)\r\nval milkQuota: Volume = milkPrice * USD(20) // returns UsGallons(5)\r\n```\r\n\r\n### FX Support\r\nCurrency Exchange Rates\r\n```scala\r\nval rate = CurrencyExchangeRate(USD(1), JPY(100))\r\nval someYen: Money = JPY(350)\r\nval dollarAmount: Money = rate.convert(someYen) // returns USD(3.5)\r\nval someBucks: Money = USD(23.50)\r\nval yenAmount: Money = rate * someBucks \t\t// returns JPY(2350)\r\n```\r\n\r\n### Money Context\r\nA MoneyContext can be implicitly declared to define default settings and applicable exchange rates.\r\nThis allows your application to work with a default currency based on an application configuration.\r\nIt also provides support for dynamically updating exchange rates and using those rates for automatic conversions between currencies.\r\nThe technique and frequency chosen for exchange rate updates is completely in control of the application.\r\n```scala\r\nimplicit val moneyContext = MoneyContext(defCur, curList, exchangeRates)\r\nval someMoney = Money(350) // 350 in the default Cur\r\nval usdMoney: Money = someMoney in USD\r\nval usdDouble: Double = someMoney to USD\r\nval yenCost: Money = (energyPrice * MegawattHours(5)) in JPY\r\nval northAmericanSales: Money = (CAD(275) + USD(350) + MXN(290)) in USD\r\n```\r\n\r\n## Quantity Ranges\r\nUsed to represent a range of Quantity values between an upper and lower bound\r\n```scala\r\nval load1: Power = Kilowatts(1000)\r\nval load2: Power = Kilowatts(5000)\r\nval range: QuantityRange[Power] = QuantityRange(load1, load2)\r\n```\r\nUse multiplication and division to create a Seq of ranges from the original\r\n```scala\r\n// Create a Seq of 10 sequential ranges starting with the original and each the same size as the original\r\nval rs1 = range * 10\r\n// Create a Seq of 10 sequential ranges each 1/10th of the original size\r\nval rs2 = range / 10\r\n// Create a Seq of 10 sequential ranges each with a size of 400 kilowatts\r\nval rs3 = range / Kilowatts(400)\r\n```\r\nApply foreach, map and foldLeft/foldRight directly to QuantityRanges with a divisor\r\n```scala\r\n// foreach over each of the 400 kilometer ranges within the range\r\nrange.foreach(Kilometers(400)) {r => ???}\r\n// map over each of 10 even parts of the range\r\nrange.map(10) {r => ???}\r\n// fold over each 10 even parts of the range\r\nrange.foldLeft(10)(0) {(z, r) => ???}\r\n```\r\n\r\n## Natural Language Features\r\nImplicit conversions give the DSL some features that allows client code to express quantities in a more natural way.\r\n```scala\r\n// Create Quantities using Unit Of Measure Factory objects (no implicits required)\r\nval load = Kilowatts(100)\r\nval time = Hours(3.75)\r\nval money = USD(112.50)\r\nval price = Price(money, MegawattHours(1))\r\n// Create Quantities using Unit of Measure names and/or symbols (uses implicits)\r\nval load1 = 100 kW \t\t\t// Simple expressions don’t need dots\r\nval load2 = 100 megaWatts\r\nval time = 3.hours + 45.minutes // Compound expressions may need dots\r\n// Create Quantities using operations between other Quantities\r\nval energyUsed = 100.kilowatts * (3.hours + 45.minutes)\r\nval price = 112.50.USD / 1.megawattHours\r\nval speed = 55.miles / 1.hours\r\n// Create Quantities using formatted Strings\r\nval load = Power(\"40 MW\")\t\t// 40 MW\r\n```\r\nThe last conversion is useful for automatically interpreting strings from user input, json marshaller and other sources\r\n\r\n## Type Hierarchy\r\nThe type hierarchy includes two root base traits:  Quantity and UnitOfMeasure\r\n\r\n### Quantity\r\nQuantity measures the magnitude or multitude of some thing.  Classes extending Quantity represent the\r\nvarious types of quantities that can be measured.  These are our alternatives to just using Double.\r\nCommon 'Base' Quantities include Mass, Temperature, Length, Time, Energy, etc.\r\n\r\nDerived Quantities are based on one or more other quantities.  Typical examples include Time Derivatives.\r\n\r\nSpeed is the 1st Time Derivative of Length (Distance), Acceleration is the 2nd Time Derivative.\r\n```scala\r\nval distance: Length = Kilometers(100)\r\nval time: Time = Hours(2)\r\nval speed: Speed = distance / time\r\nassert(speed.toKilometersPerHour == 50.0)\r\nval acc: Acceleration = Meters(50) / Second(1) / Second(1)\r\nassert(acc.toMetersPerSecondSquared == 50)\r\n```\r\nPower is the 1st Time Derivative of Energy, PowerRamp is the 2nd\r\n```scala\r\nval energy: Energy = KilowattHours(100)\r\nval time: Time = Hours(2)\r\nval power: Power = energy / time\r\nassert(power.toKilowatts == 50.0)\r\nval ramp: PowerRamp = KilowattHours(50) / Hours(1) / Hours(1)\r\nassert(ramp.toKilowattsPerHour == 50)\r\n```\r\n\r\nSquants currently supports over 40 quantity types.\r\n\r\n### Unit of Measure\r\nUnitOfMeasure is the scale or multiplier in which the Quantity is being measured.\r\n\r\nFor each Quantity a series of UOM objects implement a base UOM trait typed to that Quantity.\r\nThe UOM objects define the unit symbols and conversion settings.\r\nFactory methods in each UOM object create instances of the corresponding Quantity.\r\n\r\nFor example UOM objects extending LengthUnit can be used to create Length quantities\r\n```scala\r\nval len1: Length = Inches(5)\r\nval len2: Length = Meters(4.3)\r\nval len3: Length = UsMiles(345.2)\r\n```\r\nUnits of Measure for Time include Milliseconds, Seconds, Minutes, Hours, and Days\r\n\r\nUnits of Measure for Temperature include Celsius, Kelvin, and Fahrenheit\r\n\r\nUnits of Measure for Mass include Grams, Kilograms, etc.\r\n\r\nSquants currently supports over 120 units of measure\r\n\r\n## Use Cases\r\n\r\n### Dimensional Analysis\r\n\r\nThe primary use case for Squants, as described above, is to produce code that is typesafe with in domains\r\nthat perform dimensional analysis.\r\n```scala\r\nval energyPrice: Price[Energy] = 45.25.money / megawattHour\r\nval energyUsage: Energy = 345.kilowatts * 5.4.hours\r\nval energyCost: Money = energyPrice * energyUsage\r\n\r\nval dodgeViper: Acceleration = 60.miles / hour / 3.9.seconds\r\nval speedAfter5Seconds: Velocity = dodgeViper * 5.seconds\r\nval TimeTo100MPH: Time = 100.miles / hour / dodgeViper\r\n\r\nval density: Density = 1200.kilograms / cubicMeter\r\nval volFlowRate: VolumeFlowRate = 10.gallons / minute\r\nval flowTime: Time = 30.minutes\r\nval totalMassFlow: Mass = volFlowRate * flowTime * density\r\n```\r\n\r\n### Domain Modeling\r\nAnother excellent use case for Squants is stronger types for fields in your domain model.\r\nThis is OK ...\r\n```scala\r\ncase class Generator(id: String, maxLoadKW: Double, rampRateKWph: Double,\r\noperatingCostPerMWh: Double, currency: String, maintenanceTimeHours: Double)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5000, 7500, 75.4, \"USD\", 1.5)\r\nval gen2 = Generator(\"Gen2\", 100, 250, 2944.5, \"JPY\", 0.5)\r\nassetManagementActor ! ManageGenerator(gen1)\r\n```\r\n… but this is much better\r\n```scala\r\ncase class Generator(id: String, maxLoad: Power, rampRate: PowerRamp,\r\noperatingCost: Price[Energy], maintenanceTime: Time)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5 MW, 7.5.MW/hour, 75.4.USD/MWh, 1.5 hours)\r\nval gen2 = Generator(\"Gen2\", 100 kW, 250 kWph, 2944.5.JPY/MWh, 30 minutes)\r\nassetManagementActor ! ManageGenerator(gen1)\r\n```\r\n\r\n### Anticorruption Layers\r\n\r\nCreate wrappers around external services that use basic types to represent quantities.\r\nYour application code then uses the ACL to communicate with that system thus eliminating the need to deal\r\nwith type and scale conversions in your application logic.\r\n```scala\r\nclass ScadaServiceAnticorruption(val service: ScadaService) {\r\n  // ScadaService returns load as Double representing Megawatts\r\n  def getLoad: Power = Megawatts(service.getLoad(meterId))\r\n  }\r\n  // ScadaService.sendTempBias requires a Double representing Fahrenheit\r\n  def sendTempBias(temp: Temperature) =\r\n    service.sendTempBias(temp.to(Fahrenheit))\r\n}\r\n```\r\nImplement the ACL as a trait and mix in to the application's services where needed.\r\n```scala\r\ntrait WeatherServiceAntiCorruption {\r\n  val service: WeatherService\r\n  def getTemperature: Temperature = Celsius(service.getTemperature)\r\n  def getIrradiance: Irradiance = WattsPerSquareMeter(service.getIrradiance)\r\n}\r\n```\r\nExtend the pattern to provide multi-currency support\r\n```scala\r\nclass MarketServiceAnticorruption(val service: MarketService)\r\n     (implicit val moneyContext: = MoneyContext) {\r\n  // MarketService.getPrice returns a Double representing $/MegawattHour\r\n  def getPrice: Price[Energy] =\r\n    (USD(service.getPrice) in moneyContext.defaultCurrency) / megawattHour\r\n  // MarketService.sendBid requires a Double representing $/MegawattHour\r\n  // and another Double representing the max amount of energy in MegawattHours\r\n  def sendBid(bid: Price[Energy], limit: Energy) =\r\n    service.sendBid((bid * megawattHour) to USD, limit to MegawattHours)\r\n}\r\n```\r\nBuild Anticorruption into Akka routers\r\n```scala\r\n// LoadReading message used within the Squant’s enabled application context\r\ncase class LoadReading(meterId: String, time: Long, load: Power)\r\nclass ScadaLoadListener(router: Router) extends Actor {\r\n  def receive = {\r\n   // ScadaLoadReading, from an external service, types load as a string\r\n   // eg, “10.3 MW”, “345 kW”\r\n   case msg @ ScadaLoadReading(meterId, time, loadString) ⇒\r\n    // This handler converts the string to a Power value and emits the events\r\n    // to the routees which are actors within an app context that uses Squants\r\n    router.route(LoadReading(meterId, time, Power(loadString)), sender())\r\n  }\r\n}\r\n```\r\n... and REST API's with contracts that require basic types\r\n```scala\r\ntrait LoadRoute extends HttpService {\r\n  def repo: LoadRepository\r\n  val loadRoute = {\r\n    path(\"meter-reading\") {\r\n      // REST API contract requires load value and units in different fields\r\n      // Units are string values that may be 'kW' or 'MW'\r\n      post {\r\n        parameters(meterId, time, loadDouble, unit) { (meterId, time, loadDouble, unit) =>\r\n          complete {\r\n            val load = unit match {\r\n              case \"kW\" => Kilowatts(loadDouble)\r\n              case \"MW\" => Megawatts(loadDouble)\r\n            }\r\n            repo.SaveLoad(meterId, time, load)\r\n          }\r\n        }\r\n      } ~\r\n      // REST API contract requires load returned as a number representing megawatts\r\n      get {\r\n        parameters(meterId, time) { (meterId, time) =>\r\n          complete {\r\n            repo.GetLoad(meterId, time) to Megawatts\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}