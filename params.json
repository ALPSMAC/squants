{"name":"Squants","tagline":"The Scala API for Quantities, Units of Measure and Dimensional Analysis","body":"Squants is a framework of data types and a domain specific language (DSL) for representing Quantities,\r\ntheir Units of Measure, and their Dimensional relationships.\r\nThe API supports typesafe dimensional analysis, improved domain models and more.\r\nAll types are immutable and thread-safe.\r\n\r\n[GitHub](https://github.com/garyKeorkunian/squants)\r\n|\r\n[User Forum](https://groups.google.com/forum/#!forum/squants)\r\n\r\n### Current Versions\r\nCurrent Release: **0.2.3**\r\n([API Docs](https://oss.sonatype.org/service/local/repositories/releases/archive/com/squants/squants_2.10/0.2.3/squants_2.10-0.2.3-javadoc.jar/!/index.html#squants.package))\r\n\r\nDevelopment Build: **0.2.4-SNAPSHOT**\r\n([API Docs](https://oss.sonatype.org/service/local/repositories/snapshots/archive/com/squants/squants_2.10/0.2.4-SNAPSHOT/squants_2.10-0.2.4-SNAPSHOT-javadoc.jar/!/index.html#squants.package))\r\n\r\n[![Build Status](https://travis-ci.org/garyKeorkunian/squants.png?branch=master)](https://travis-ci.org/garyKeorkunian/squants)\r\n\r\n## Installation\r\nRepository hosting for Squants is provided by Sonatype.\r\nTo use Squants in your SBT project you will need to add the following dependency to your build.\r\n\r\n    \"com.squants\"  %% \"squants\"  % \"0.2.3\"\r\n\r\nTo use Squants interactively in the Scala REPL, clone the git repo and run `sbt console`\r\n\r\n    git clone https://github.com/garyKeorkunian/squants\r\n    cd squants\r\n    sbt console\r\n\r\n## Better Dimensional Analysis\r\n*The Trouble with Doubles*\r\n\r\nWhen building programs that perform some type of dimensional analysis, developers are quick to declare\r\nquantities using a basic numeric type, usually Double.  While this may be satisfactory in some situations,\r\nit can often lead to semantic and other logic issues.\r\n\r\nFor example, when using a Double to describe a quantity of Energy (kWh) and Power (kW), it is possible\r\nto compile a program that adds these two values together.  This is not appropriate as kW and kWh\r\nmeasure two different quantities.  The unit kWh is used to measure an amount of Energy used\r\nor produced.  The unit kW is used to measure Power/Load, the rate at which Energy is being used\r\nor produced, that is, Power is the first time derivative of Energy.\r\n\r\n*Power = Energy / Time*\r\n\r\nConsider the following code\r\n\r\n```scala\r\nval loadKw: Double = 1.2\r\nval energyMwh: Double = 24.2\r\nval sumKw = loadKw + energyMwh\r\n```\r\n\r\nwhich not only adds different quantity types (load vs energy), it also fails to convert the scales (Mega vs Kilo).\r\nBecause this code compiles, detection of these errors is pushed further into the development cycle.\r\n\r\n### Dimensional Types\r\nThe Squants Type Library and DSL helps prevent errors like these by type checking operations at compile time and\r\nautomatically applying scale and type conversions (see below) at run-time.  For example,\r\n\r\n```scala\r\nval load1: Power = Kilowatts(12)\r\nval load2: Power = Megawatts(0.023)\r\nval sum = load1 + load2\r\nsum should be(Kilowatts(35))\r\nsum should be(Megawatts(0.035))\r\n```\r\n\r\nis a valid assertion because Kilowatts and Megawatts are both measures of load.  Only the scale is\r\ndifferent and the framework applies an appropriate conversion.  Also, notice that keeping track of\r\nthe scale within the value name is no longer needed.\r\n\r\n### Dimensional Type Safety\r\nThe following code highlights the type safety features.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1.2)\r\nval energy: Energy = KilowattHours(23.0)\r\nval sum = load + energy // Invalid operation - does not compile\r\n```\r\nThe invalid expression prevents the code from compiling, catching the error made when using Double above.\r\n\r\n### Smart Type Conversions\r\nDimensionally smart type conversions are a key feature of Squants.\r\nMost conversions are implemented by defining relationships between Quantity types using infix operations.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1.2)\r\nval time: Time = Hours(2)\r\nval energyUsed: Energy = load * time\r\nenergyUsed should be(KilowattHours(2.4))\r\n```\r\nThis code demonstrates use of the Power.* method, defined as an infix operator that takes a Time\r\nvalue and returns an Energy value, conversely\r\n\r\n```scala\r\nval aveLoad: Power = energyUsed / time\r\naveLoad should be(Kilowatts(1.2)\r\n```\r\ndemonstrates use of the Energy./ method that takes a Time and returns a Power\r\n\r\n### Unit Conversions\r\nIf necessary, the value in the desired unit can be extracted with the `to` method.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1200)\r\nval mw: Double = load to Kilowatts // returns 1200.0 (default method)\r\nval gw: Double = load to Gigawatts // returns 0.0012\r\nval my: Double = load to MyPowerUnit // returns ??? Whatever you want\r\nval kw: Double = load toKilowatts // returns 1200.0 (convenience method)\r\n```\r\nStrings formatted in the desired unit is also supported\r\n\r\n```scala\r\nval kw: String = load toString Kilowatts // returns “1200.0 kW”\r\nval mw: String = load toString Megawatts // returns “1.2 MW”\r\nval gw: String = load toString Gigawatts // returns “0.0012 GW”\r\n```\r\n\r\n### Approximations\r\nCreate an implicit Quantity value to be used as a tolerance in approximate equality comparisons.\r\nUse the `approx` method (`=~` operator) like the `equals` method or `==` operator\r\n\r\n```scala\r\nimplicit val tolerance = Watts(.1)\r\nval load = Kilowatts(2.0)\r\nval reading = Kilowatts(1.9999)\r\nload =~ reading should be(true)\r\n```\r\n\r\n## Market Package\r\nMarket Types are similar but not quite the same as other quantities in the library.\r\nThe primary type, Money, is derived from Quantity, and its Units of Measure are Currencies.\r\nHowever, because the conversion multipliers between units can not be predefined, many of the behaviors have been\r\noverridden and augmented to realize correct behavior.\r\n\r\n### Money\r\nA Quantity of purchasing power measured in units we call Currencies.\r\nCreate Money values using standard Currency codes.\r\n\r\n```scala\r\nval tenBucks: Money = USD(10)\r\nval someYen: Money = JPY(1200)\r\nval goldStash: Money = XAU(50)\r\nval digitalStash: Money = BTC(50)\r\n```\r\n\r\n### Price\r\nA Ratio between Money and another Quantity.\r\nA Price value must be typed on a Quantity.\r\nIt can be denominated in any defined Currency.\r\n\r\n*Price = Money / Quantity*\r\n\r\n```scala\r\nval threeForADollar: Price[Dimensionless] = USD(1) / Each(3)\r\nval energyPrice: Price[Energy] = USD(102.20) / MegawattHours(1)\r\nval milkPrice: Price[Volume] = USD(4) / UsGallons(1)\r\n\r\nval costForABunch: Money = threeForADollar * Dozen(10) // returns USD(40)\r\nval energyCost: Money = energyPrice * MegawattHours(4) // returns USD(408.80)\r\nval milkQuota: Volume = milkPrice * USD(20) // returns UsGallons(5)\r\n```\r\n\r\n### FX Support\r\nCurrency Exchange Rates\r\n\r\n```scala\r\nval rate = CurrencyExchangeRate(USD(1), JPY(100))\r\nval someYen: Money = JPY(350)\r\nval dollarAmount: Money = rate.convert(someYen) // returns USD(3.5)\r\nval someBucks: Money = USD(23.50)\r\nval yenAmount: Money = rate * someBucks \t\t// returns JPY(2350)\r\n```\r\n\r\n### Money Context\r\nA MoneyContext can be implicitly declared to define default settings and applicable exchange rates within a context.\r\nThis allows your application to work with a default currency based on an application configuration or other dynamic source.\r\nIt also provides support for updating exchange rates and using those rates for automatic conversions between currencies.\r\nThe technique and frequency chosen for exchange rate updates is completely in control of the application.\r\n\r\n```scala\r\nimplicit val moneyContext = MoneyContext(defCur, curList, exchangeRates)\r\nval someMoney = Money(350) // 350 in the default Cur\r\nval usdMoney: Money = someMoney in USD\r\nval usdDouble: Double = someMoney to USD\r\nval yenCost: Money = (energyPrice * MegawattHours(5)) in JPY\r\nval northAmericanSales: Money = (CAD(275) + USD(350) + MXN(290)) in USD\r\n```\r\n\r\n## Quantity Ranges\r\nUsed to represent a range of Quantity values between an upper and lower bound\r\n\r\n```scala\r\nval load1: Power = Kilowatts(1000)\r\nval load2: Power = Kilowatts(5000)\r\nval range: QuantityRange[Power] = QuantityRange(load1, load2)\r\n```\r\nUse multiplication and division to create a Seq of ranges from the original\r\n\r\n```scala\r\n// Create a Seq of 10 sequential ranges starting with the original and each the same size as the original\r\nval rs1 = range * 10\r\n// Create a Seq of 10 sequential ranges each 1/10th of the original size\r\nval rs2 = range / 10\r\n// Create a Seq of 10 sequential ranges each with a size of 400 kilowatts\r\nval rs3 = range / Kilowatts(400)\r\n```\r\nApply foreach, map and foldLeft/foldRight directly to QuantityRanges with a divisor\r\n\r\n```scala\r\n// foreach over each of the 400 kilometer ranges within the range\r\nrange.foreach(Kilometers(400)) {r => ???}\r\n// map over each of 10 even parts of the range\r\nrange.map(10) {r => ???}\r\n// fold over each 10 even parts of the range\r\nrange.foldLeft(10)(0) {(z, r) => ???}\r\n```\r\n\r\n## Natural Language Features\r\nImplicit conversions give the DSL some features that allows client code to express quantities in a more natural way.\r\n\r\nCreate Quantities using Unit Of Measure Factory objects (no implicits required)\r\n\r\n```scala\r\nval load = Kilowatts(100)\r\nval time = Hours(3.75)\r\nval money = USD(112.50)\r\nval price = Price(money, MegawattHours(1))\r\n```\r\n\r\nCreate Quantities using Unit of Measure names and/or symbols (uses implicits)\r\n\r\n```scala\r\nval load1 = 100 kW \t\t\t        // Simple expressions don’t need dots\r\nval load2 = 100 megaWatts\r\nval time = 3.hours + 45.minutes     // Compound expressions may need dots\r\n```\r\n\r\nCreate Quantities using operations between other Quantities\r\n\r\n```scala\r\nval energyUsed = 100.kilowatts * (3.hours + 45.minutes)\r\nval price = 112.50.USD / 1.megawattHours\r\nval speed = 55.miles / 1.hours\r\n```\r\n\r\nCreate Quantities using formatted Strings\r\n\r\n```scala\r\nval load = Power(\"40 MW\")\t\t// 40 MW\r\n```\r\n\r\nUse single unit values to simplify expressions\r\n\r\n```scala\r\n// Hours(1) == 1.hours == hour\r\nval ramp = 100.kilowatts / hour\r\nval speed = 100.kilometers / hour\r\n\r\n// MegawattHours(1) == 1.megawattHours == megawattHour == MWh\r\nval hi = 100.dollars / MWh\r\nval low = 40.dollars / megawattHour\r\n```\r\n\r\nImplicit conversion support for using Numbers to lead some expressions\r\n\r\n```scala\r\nval price = 10 / dollar\t    // 1 USD / 10 ea\r\nval freq = 60 / second\t    // 60 Hz\r\nval load = 10 * 4.MW\t\t// 40 MW\r\n```\r\n\r\nCreate Quantity Ranges using `to` or `plusOrMinus` (`+-`) operators\r\n\r\n```scala\r\nval range1 = 1000.kW to 5000.kW\t    // 1000.kW to 5000.kW\r\nval range2 = 5000.kW +- 1000.kW     // 4000.kW to 6000.kW\r\n```\r\n\r\n### Numeric Support\r\nMost Quantities that support implicit conversions also include an implicit Numeric object that can be imported\r\nto your code where Numeric support is required.  These follow the following pattern:\r\n\r\n```scala\r\nimport squants.mass.MassConversions.MassNumeric\r\n\r\nval sum = List(Kilograms(100), Grams(34510)).sum\r\n```\r\n\r\n## Type Hierarchy\r\nThe type hierarchy includes two root base traits:  Quantity and UnitOfMeasure\r\n\r\n### Quantity\r\nQuantity measures the magnitude or multitude of some thing.  Classes extending Quantity represent the\r\nvarious types of quantities that can be measured.  These are our alternatives to just using Double.\r\nCommon 'Base' Quantities include Mass, Temperature, Length, Time, Energy, etc.\r\n\r\nDerived Quantities are based on one or more other quantities.  Typical examples include Time Derivatives.\r\n\r\nSpeed is the 1st Time Derivative of Length (Distance), Acceleration is the 2nd Time Derivative.\r\n\r\n```scala\r\nval distance: Length = Kilometers(100)\r\nval time: Time = Hours(2)\r\nval speed: Speed = distance / time\r\nspeed.toKilometersPerHour should be(50.0)\r\nval acc: Acceleration = Meters(50) / Second(1) / Second(1)\r\nacc.toMetersPerSecondSquared should be(50)\r\n```\r\nPower is the 1st Time Derivative of Energy, PowerRamp is the 2nd\r\n\r\n```scala\r\nval energy: Energy = KilowattHours(100)\r\nval time: Time = Hours(2)\r\nval power: Power = energy / time\r\npower.toKilowatts should be(50.0)\r\nval ramp: PowerRamp = KilowattHours(50) / Hours(1) / Hours(1)\r\nramp.toKilowattsPerHour should be(50)\r\n```\r\n\r\nSquants currently supports over 50 quantity types.\r\n\r\n### Unit of Measure\r\nUnitOfMeasure is the scale or multiplier in which the Quantity is being measured.\r\n\r\nFor each Quantity a series of UOM objects implement a base UOM trait typed to that Quantity.\r\nThe UOM objects define the unit symbols and conversion settings.\r\nFactory methods in each UOM object create instances of the corresponding Quantity.\r\n\r\nFor example UOM objects extending LengthUnit can be used to create Length quantities\r\n\r\n```scala\r\nval len1: Length = Inches(5)\r\nval len2: Length = Meters(4.3)\r\nval len3: Length = UsMiles(345.2)\r\n```\r\nUnits of Measure for Time include Milliseconds, Seconds, Minutes, Hours, and Days\r\n\r\nUnits of Measure for Temperature include Celsius, Kelvin, and Fahrenheit\r\n\r\nUnits of Measure for Mass include Grams, Kilograms, etc.\r\n\r\nSquants currently supports over 150 units of measure\r\n\r\n## Use Cases\r\n\r\n### Dimensional Analysis\r\n\r\nThe primary use case for Squants, as described above, is to produce code that is typesafe with in domains\r\nthat perform dimensional analysis.\r\n\r\n```scala\r\nval energyPrice: Price[Energy] = 45.25.money / megawattHour\r\nval energyUsage: Energy = 345.kilowatts * 5.4.hours\r\nval energyCost: Money = energyPrice * energyUsage\r\n\r\nval dodgeViper: Acceleration = 60.miles / hour / 3.9.seconds\r\nval speedAfter5Seconds: Velocity = dodgeViper * 5.seconds\r\nval TimeTo100MPH: Time = 100.miles / hour / dodgeViper\r\n\r\nval density: Density = 1200.kilograms / cubicMeter\r\nval volFlowRate: VolumeFlowRate = 10.gallons / minute\r\nval flowTime: Time = 30.minutes\r\nval totalMassFlow: Mass = volFlowRate * flowTime * density\r\n```\r\n\r\n### Domain Modeling\r\nAnother excellent use case for Squants is stronger types for fields in your domain model.\r\nThis is OK ...\r\n\r\n```scala\r\ncase class Generator(id: String, maxLoadKW: Double, rampRateKWph: Double,\r\noperatingCostPerMWh: Double, currency: String, maintenanceTimeHours: Double)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5000, 7500, 75.4, \"USD\", 1.5)\r\nval gen2 = Generator(\"Gen2\", 100, 250, 2944.5, \"JPY\", 0.5)\r\nassetManagementActor ! ManageGenerator(gen1)\r\n```\r\n… but this is much better\r\n\r\n```scala\r\ncase class Generator(id: String, maxLoad: Power, rampRate: PowerRamp,\r\noperatingCost: Price[Energy], maintenanceTime: Time)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5 MW, 7.5.MW/hour, 75.4.USD/MWh, 1.5 hours)\r\nval gen2 = Generator(\"Gen2\", 100 kW, 250 kWph, 2944.5.JPY/MWh, 30 minutes)\r\nassetManagementActor ! ManageGenerator(gen1)\r\n```\r\n\r\n### Anticorruption Layers\r\n\r\nCreate wrappers around external services that use basic types to represent quantities.\r\nYour application code then uses the ACL to communicate with that system thus eliminating the need to deal\r\nwith type and scale conversions in your application logic.\r\n\r\n```scala\r\nclass ScadaServiceAnticorruption(val service: ScadaService) {\r\n  // ScadaService returns load as Double representing Megawatts\r\n  def getLoad: Power = Megawatts(service.getLoad(meterId))\r\n  }\r\n  // ScadaService.sendTempBias requires a Double representing Fahrenheit\r\n  def sendTempBias(temp: Temperature) =\r\n    service.sendTempBias(temp.to(Fahrenheit))\r\n}\r\n```\r\n\r\nImplement the ACL as a trait and mix in to the application's services where needed.\r\n\r\n```scala\r\ntrait WeatherServiceAntiCorruption {\r\n  val service: WeatherService\r\n  def getTemperature: Temperature = Celsius(service.getTemperature)\r\n  def getIrradiance: Irradiance = WattsPerSquareMeter(service.getIrradiance)\r\n}\r\n```\r\n\r\nExtend the pattern to provide multi-currency support\r\n\r\n```scala\r\nclass MarketServiceAnticorruption(val service: MarketService)\r\n     (implicit val moneyContext: = MoneyContext) {\r\n  // MarketService.getPrice returns a Double representing $/MegawattHour\r\n  def getPrice: Price[Energy] =\r\n    (USD(service.getPrice) in moneyContext.defaultCurrency) / megawattHour\r\n  // MarketService.sendBid requires a Double representing $/MegawattHour\r\n  // and another Double representing the max amount of energy in MegawattHours\r\n  def sendBid(bid: Price[Energy], limit: Energy) =\r\n    service.sendBid((bid * megawattHour) to USD, limit to MegawattHours)\r\n}\r\n```\r\n\r\nBuild Anticorruption into Akka routers\r\n\r\n```scala\r\n// LoadReading message used within the Squant’s enabled application context\r\ncase class LoadReading(meterId: String, time: Long, load: Power)\r\nclass ScadaLoadListener(router: Router) extends Actor {\r\n  def receive = {\r\n   // ScadaLoadReading, from an external service, types load as a string\r\n   // eg, “10.3 MW”, “345 kW”\r\n   case msg @ ScadaLoadReading(meterId, time, loadString) ⇒\r\n    // This handler converts the string to a Power value and emits the events\r\n    // to the routees which are actors within an app context that uses Squants\r\n    router.route(LoadReading(meterId, time, Power(loadString)), sender())\r\n  }\r\n}\r\n```\r\n\r\n... and REST API's with contracts that require basic types\r\n\r\n```scala\r\ntrait LoadRoute extends HttpService {\r\n  def repo: LoadRepository\r\n  val loadRoute = {\r\n    path(\"meter-reading\") {\r\n      // REST API contract requires load value and units in different fields\r\n      // Units are string values that may be 'kW' or 'MW'\r\n      post {\r\n        parameters(meterId, time, loadDouble, unit) { (meterId, time, loadDouble, unit) =>\r\n          complete {\r\n            val load = unit match {\r\n              case \"kW\" => Kilowatts(loadDouble)\r\n              case \"MW\" => Megawatts(loadDouble)\r\n            }\r\n            repo.saveLoad(meterId, time, load)\r\n          }\r\n        }\r\n      } ~\r\n      // REST API contract requires load returned as a number representing megawatts\r\n      get {\r\n        parameters(meterId, time) { (meterId, time) =>\r\n          complete {\r\n            repo.getLoad(meterId, time) to Megawatts\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n## Roadmap\r\n\r\nThe following features and improvements are planned for the 1.0 release\r\n\r\n* JSON Marshalling Support perhaps with a companion project or two for specific bindings (ie, squants-json4s)\r\n* Validate and improve Money and FX Support\r\n* Implement improved Vector Quantity support (Velocity, Acceleration, Force, etc)\r\n* Additional Quantity Types, Units and Dimensional Conversions\r\n* Optimize Performance and / or Conversion Precisions\r\n  * Using a Double as the underlying value is likely providing the best performance\r\n  * Better precision will likely take the form of replacing the underlying Double value with a Generic Type\r\n  so that user code can choose a more precise type such as those provided by the\r\n  [Spire](https://github.com/non/spire) project\r\n* Enhance documentation and support presence\r\n* Typesafe Activator Sample Project /  Template\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}