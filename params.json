{"name":"Squants","tagline":"The Scala API for Quantities, Units of Measure and Dimensional Analysis","body":"Squants is a framework of data types and a domain specific language (DSL) for representing Quantities,\r\ntheir Units of Measure, and their Dimensional relationships.\r\nThe API supports typesafe dimensional analysis, improved domain models and more.\r\nAll types are immutable and thread-safe.\r\n\r\n[GitHub](https://github.com/garyKeorkunian/squants)\r\n|\r\n[User Forum](https://groups.google.com/forum/#!forum/squants)\r\n|\r\n[Wiki](https://github.com/garyKeorkunian/squants/wiki)\r\n\r\n### Current Versions\r\nCurrent Release: **0.5.3**\r\n([API Docs](https://oss.sonatype.org/service/local/repositories/releases/archive/com/squants/squants_2.11/0.5.3/squants_2.11-0.5.3-javadoc.jar/!/index.html#squants.package))\r\n\r\nDevelopment Build: **0.6.1-SNAPSHOT**\r\n([API Docs](https://oss.sonatype.org/service/local/repositories/snapshots/archive/com/squants/squants_2.11/0.6.1-SNAPSHOT/squants_2.11-0.6.1-SNAPSHOT-javadoc.jar/!/index.html#squants.package))\r\n\r\n[Release History](https://github.com/garyKeorkunian/squants/wiki/Release-History)\r\n\r\n[![Build Status](https://travis-ci.org/garyKeorkunian/squants.png?branch=master)](https://travis-ci.org/garyKeorkunian/squants)\r\n\r\nBuild services provided by [Travis CI](https://travis-ci.com/) \r\n\r\nNOTE - This README reflects feature set in the branch it can be found.  \r\nFor more information on feature availability of a specific version see the Release History or the README for a that version \r\n\r\n## Installation\r\nRepository hosting for Squants is provided by [Sonatype](https://oss.sonatype.org/).\r\nTo use Squants in your SBT project add the following dependency to your build.\r\n\r\n    \"com.squants\"  %% \"squants\"  % \"0.5.3\"\r\nor\r\n\r\n    \"com.squants\"  %% \"squants\"  % \"0.6.1-SNAPSHOT\"\r\n\r\n\r\nTo use Squants in your Maven project add the following dependency\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.squants</groupId>\r\n    <artifactId>squants_2.11</artifactId>\r\n    <version>0.5.3</version>\r\n</dependency>\r\n```\r\n\r\nBeginning with Squants 0.4.x series, both Scala 2.10 and 2.11 builds are available.\r\n\r\nTo use Squants interactively in the Scala REPL, clone the git repo and run `sbt squantsJVM/console`\r\n\r\n    git clone https://github.com/garyKeorkunian/squants\r\n    cd squants\r\n    sbt squantsJVM/console\r\n\r\n## Type Safe Dimensional Analysis\r\n*The Trouble with Doubles*\r\n\r\nWhen building programs that perform dimensional analysis, developers are quick to declare\r\nquantities using a basic numeric type, usually Double.  While this may be satisfactory in some situations,\r\nit can often lead to semantic and other logic issues.\r\n\r\nFor example, when using a Double to describe quantities of Energy (kWh) and Power (kW), it is possible\r\nto compile a program that adds these two values together.  This is not appropriate as kW and kWh\r\nmeasure quantities of two different dimensions.  The unit kWh is used to measure an amount of Energy used\r\nor produced.  The unit kW is used to measure Power/Load, the rate at which Energy is being used\r\nor produced, that is, Power is the first time derivative of Energy.\r\n\r\n*Power = Energy / Time*\r\n\r\nConsider the following code\r\n\r\n```scala\r\nval loadKw = 1.2                    // Double: 1.2\r\nval energyMwh = 24.2                // Double: 24.2        \r\nval sumKw = loadKw + energyMwh      // Double: 25.4\r\n```\r\n\r\nwhich not only adds quantities of different dimensions (Power vs Energy),\r\nit also fails to convert the scales implied in the val names (Mega vs Kilo).\r\nBecause this code compiles, detection of these errors is pushed further into the development cycle.\r\n\r\n### Dimensional Type Safety\r\n\r\n_Only quantities with the same dimensions may be compared, equated, added, or subtracted._\r\n\r\nSquants helps prevent errors like these by type checking operations at compile time and\r\nautomatically applying scale and type conversions at run-time.  For example,\r\n\r\n```scala\r\nval load1: Power = Kilowatts(12)        // returns Power(12, Kilowatts) or 12 kW\r\nval load2: Power = Megawatts(0.023)     // Power: 0.023 MW\r\nval sum = load1 + load2                 // Power: 35 kW - unit on left side is preserved\r\nsum should be(Kilowatts(35))            \r\nsum should be(Megawatts(0.035))         // comparisons automatically convert scale \r\n```\r\n\r\nworks because Kilowatts and Megawatts are both units of Power.  Only the scale is\r\ndifferent and the library applies an appropriate conversion.  Also, notice that keeping track of\r\nthe scale within the value name is no longer needed.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1.2)            // Power: 1.2 kW\r\nval energy: Energy = KilowattHours(23.0)    // Energy: 23 kWH\r\nval sum = load + energy                     // Invalid operation - does not compile\r\n```\r\nThe unsupported operation in this expression prevents the code from compiling,\r\ncatching the error made when using Double in the example above.\r\n\r\n### Dimensionally Correct Type Conversions\r\n\r\n_One may take quantities with different dimensions, and multiply or divide them._\r\n\r\nDimensionally correct type conversions are a key feature of Squants.\r\nConversions are implemented by defining relationships between Quantity types using the * and / operators.\r\n\r\nThe following code demonstrates creating ratio between two quantities of the same dimension, \r\nresulting in a dimensionless value:\r\n\r\n```scala\r\nval ratio = Days(1) / Hours(3)  // Double: 8.0\r\n```\r\n\r\nThis code demonstrates use of the `Power.*` method that takes a `Time` and returns an `Energy`:\r\n\r\n```scala\r\nval load = Kilowatts(1.2)                   // Power: 1.2 kW\r\nval time = Hours(2)                         // Time: 2 h\r\nval energyUsed = load * time                // Energy: 2.4 kWh\r\n```\r\n\r\nThis code demonstrates use of the `Energy./` method that takes a `Time` and returns a `Power`:\r\n\r\n```scala\r\nval aveLoad: Power = energyUsed / time      // Power: 1.2 kW\r\n```\r\n\r\n### Unit Conversions\r\n\r\nQuantity values are based in the units used to create them.\r\n\r\n```scala\r\nval loadA: Power = Kilowatts(1200)  // Power: 1200.0 kW\r\nval loadB: Power = Megawatts(1200)  // Power: 1200.0 MW\r\n```\r\n\r\nSince Squants properly equates values of a like dimension, regardless of the unit,\r\nthere is usually no reason to explicitly convert from one to the other.\r\nThis is especially true if the user code is primarily performing dimensional analysis.\r\n\r\nHowever, there are times when you may need to set a Quantity value to a specific unit (eg, for proper JSON encoding).\r\n\r\nWhen necessary, a quantity can be converted to another unit using the `in` method.\r\n\r\n```scala\r\nval loadA = Kilowatts(1200)    // Power: 1200.0 kW\r\nval loadB = loadA in Megawatts // Power: 1.2 MW\r\nval loadC = loadA in Gigawatts // Power: 0.0012 GW\r\n```\r\n\r\nSometimes you need to get the numeric value of the quantity in a specific unit\r\n(eg, for submission to an external service that requires a numeric in a specified unit \r\nor to perform analysis beyond Squant's domain)\r\n\r\nWhen necessary, the value can be extracted in the desired unit with the `to` method.\r\n\r\n```scala\r\nval load: Power = Kilowatts(1200)\r\nval kw: Double = load to Kilowatts // Double: 1200.0\r\nval mw: Double = load to Megawatts // Double: 1.2\r\nval gw: Double = load to Gigawatts // Double: 0.0012\r\n```\r\n\r\nMost types include methods with convenient aliases for the `to` methods.\r\n\r\n```\r\nval kw: Double = load toKilowatts // Double: 1200.0\r\nval mw: Double = load toMegawatts // Double: 1.20\r\nval gw: Double = load toGigawatts // Double: 0.0012\r\n```\r\n\r\nNOTE - It is important to use the `to` method for extracting the numeric value,\r\nas this ensures you will be getting the numeric value for the desired unit.\r\n`Quantity.value` should not be accessed directly.\r\nTo prevent improper usage, direct access to the `Quantity.value` field may be deprecated in a future version.\r\n\r\nCreating strings formatted in the desired unit:\r\n\r\n```scala\r\nval kw: String = load toString Kilowatts // String: “1200.0 kW”\r\nval mw: String = load toString Megawatts // String: “1.2 MW”\r\nval gw: String = load toString Gigawatts // String: “0.0012 GW”\r\n```\r\n\r\nCreating Tuple2(Double, String) that includes a numeric value and unit symbol:\r\n\r\n```scala\r\nval load: Power = Kilowatts(1200)\r\nval kw: Tuple2 = load toTuple               // Tuple2: (1200, \"kW\")\r\nval mw: Tuple2 = load toTuple Megawatts     // Tuple2: (1.2, \"MW)\r\nval gw: Tuple2 = load toTuple Gigawatts     // Tuple2: (0.0012, \"GW\")\r\n```\r\n\r\nThis can be useful for passing properly scaled quantities to other processes\r\nthat do not use Squants, or require use of more basic types (Double, String)\r\n\r\nSimple console based conversions (using DSL described below)\r\n\r\n```scala\r\n1.kilograms to Pounds       // Double: 2.2046226218487757 \r\nkilogram / pound            // Double: 2.2046226218487757\r\n \r\n2.1.pounds to Kilograms     // Double: 0.952543977 \r\n2.1.pounds / kilogram)      // Double: 0.952543977\r\n\r\n100.C to Fahrenheit         // Double: 212.0\r\n```\r\n\r\n### Mapping over Quantity values\r\nApply a `Double => Double` operation to the underlying value of a quantity, while preserving its type and unit.\r\n\r\n```scala\r\nval load = Kilowatts(2.0)                   // 2.0 kW\r\nval newLoad = load.map(v => v * 2 + 10)     // Power: 14.0 kW\r\n```\r\n\r\nThe q.map(f) method effectively expands to q.unit(f(q.to(q.unit))\r\n\r\n### Approximations\r\nCreate an implicit Quantity value to be used as a tolerance in approximations.\r\nThen use the `approx` method (or `=~`, `~=`, `≈` operators) like you would use the `equals` method (`==` operator).\r\n\r\n```scala\r\nimplicit val tolerance = Watts(.1)      // implicit Power: 0.1 W \r\nval load = Kilowatts(2.0)               // Power: 2.0 kW\r\nval reading = Kilowatts(1.9999)         // Power: 1.9999 kW\r\n\r\n // uses implicit tolerance\r\nload =~ reading should be(true)\r\nload ≈ reading should be(true)\r\nload approx reading should be(true)\r\n```\r\n\r\nThe `=~` and `≈` are the preferred operators as they have the correct precedence for equality operations.\r\nThe `~=` is provided for those who wish to use a more natural looking approx operator using standard characters.\r\nHowever, because of its lower precedence, user code may require parenthesis around these comparisons.\r\n\r\n### Vectors\r\n\r\nAll `Quantity` types in Squants represent the scalar value of a quantity.\r\nThat is, there is no direction information encoded in any of the Quantity types.\r\nThis is true even for Quantities which are normally vector quantities (ie. Velocity, Acceleration, etc).\r\n\r\nVector quantities in Squants are implemented as a case class that takes a variable parameter list of like quantities\r\nrepresenting a set of point coordinates in Cartesian space.\r\nThe dimensionality of the vector is determined by the number of arguments.\r\nMost basic vector operations are currently supported (addition, subtraction, scaling, cross and dot products)\r\n\r\n```scala\r\nval vector = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3)\r\nval magnitude: Length = vector.magnitude        // returns the scalar value of the vector\r\nval normalized = vector.normalize(Kilometers)   // returns a corresponding vector scaled to 1 of the given unit\r\n\r\nval vector2 = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3)\r\nval vectorSum = vector + vector2        // returns the sum of two vectors\r\nval vectorDiff = vector - vector2       // return the difference of two vectors\r\nval vectorScaled = vector * 5           // returns vector scaled 5 times\r\nval vectorReduced = vector / 5          // returns vector reduced 5 time\r\nval vectorDouble = vector / 5.meters    // returns vector reduced and converted to DoubleVector\r\nval dotProduct = vector * vectorDouble  // returns the Dot Product of vector and vectorDouble\r\n\r\nval crossProduct = vector crossProduct vectorDouble  // currently only supported for 3-dimensional vectors\r\n```\r\n\r\nSimple non-quantity (Double based) vectors are also supported.\r\n\r\n```scala\r\nval vector = DoubleVector(1.2, 4.3, 2.3, 5.4)   // a Four-dimensional vector\r\n```\r\n\r\n#### Dimensional conversions within Vector operations.\r\nNOTE - This feature is currently under development and the final implementation being evaluated.\r\nThe following type of operation is the goal.\r\n\r\n```scala\r\nval vectorLength = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3)\r\nval vectorArea = vectorLength * Kilometers(2)   // QuantityVector(2.4 km², 8.6 km², 4.6 km²)\r\nval vectorVelocity = vectorLength / Seconds(1)  // QuantityVector(1200.0 m/s, 4300.0 m/s, 2300.0 m/s)\r\n\r\nval vectorDouble = DoubleVector(1.2, 4.3, 2.3)\r\nval vectorLength = vectorDouble.to(Kilometers)  // QuantityVector(1.2 km, 4.3 km, 2.3 km)\r\n```\r\n\r\nCurrently dimensional conversions are supported by using the slightly verbose, but flexible map method\r\n \r\n```scala\r\nval vectorLength = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3))\r\nval vectorArea = vectorLength.map[Area](_ * Kilometers(2))      // QuantityVector(2.4 km², 8.6 km², 4.6 km²)\r\nval vectorVelocity = vectorLength.map[Velocity](_ / Seconds(1)) // QuantityVector(1200.0 m/s, 4300.0 m/s, 2300.0 m/s)\r\n\r\nval vectorDouble = DoubleVector(1.2, 4.3, 2.3)\r\nval vectorLength = vectorDouble.map[Length](Kilometers(_))      // QuantityVector(1.2 km, 4.3 km, 2.3 km)\r\n```\r\n\r\nConvert QuantityVectors to specific units using the `to` or `in` method - much like Quantities.\r\n\r\n```scala\r\nval vectorLength = QuantityVector(Kilometers(1.2), Kilometers(4.3), Kilometers(2.3))\r\nval vectorMetersNum = vectorLength.to(Meters)   // DoubleVector(1200.0, 4300.0, 2300.0)\r\nval vectorMeters = vectorLength.in(Meters)      // QuantityVector(1200.0 m, 4300.0 m, 2300.0 m)\r\n```\r\n \r\n## Market Package\r\nMarket Types are similar but not quite the same as other quantities in the library.\r\nThe primary type, Money, is a Dimensional Quantity, and its Units of Measure are Currencies.\r\nHowever, because the conversion multipliers between currency units can not be predefined,\r\nmany of the behaviors have been overridden and augmented to realize correct behavior.\r\n\r\n### Money\r\nA Quantity of purchasing power measured in Currency units.\r\nLike other quantities, the Unit of Measures are used to create Money values.\r\n\r\n```scala\r\nval tenBucks = USD(10)      // Money: 10 USD\r\nval someYen = JPY(1200)     // Money: 1200 JPY\r\nval goldStash = XAU(50)     // Money: 50 XAU\r\nval digitalCache = BTC(50)  // Money: 50 BTC\r\n```\r\n\r\n### Price\r\nA Ratio between Money and another Quantity.\r\nA Price value is typed on a Quantity and can be denominated in any defined Currency.\r\n\r\n*Price = Money / Quantity*\r\n\r\n```scala\r\nval threeForADollar = USD(1) / Each(3)              // Price[Dimensionless]: 1 USD / 3 ea\r\nval energyPrice = USD(102.20) / MegawattHours(1)    // Price[Energy]: 102.20 USD / megawattHour\r\nval milkPrice = USD(4) / UsGallons(1)               // Price[Volume]: 4 USD / gallon\r\n\r\nval costForABunch = threeForADollar * Dozen(10) // Money: 40 USD\r\nval energyCost = energyPrice * MegawattHours(4) // Money: 408.80 USD\r\nval milkQuota = milkPrice * USD(20)             // Volume: 5 gal\r\n```\r\n\r\n### FX Support\r\nCurrency Exchange Rates are used to define the conversion factors between currencies\r\n\r\n```scala\r\n// create an exchange rate\r\nval rate = CurrencyExchangeRate(USD(1), JPY(100))\r\n// OR\r\nval rate = USD / JPY(100)\r\n// OR\r\nval rate = JPY(100) -> USD(1)\r\n// OR\r\nval rate = JPY(100) toThe USD(1)\r\n\r\nval someYen: Money = JPY(350)\r\nval someBucks: Money = USD(23.50)\r\n\r\n// Use the convert method which automatically converts the money to the 'other' currency\r\nval dollarAmount: Money = rate.convert(someYen) // Money: 3.5 USD\r\nval yenAmount: Money = rate.convert(someBucks)  // Money: 2360 JPY\r\n\r\n// or just use the * operator in either direction (money * rate, or rate * money)\r\nval dollarAmount2: Money = rate * someYen       // Money: 3.5 USD\r\nval yenAmount2: Money = someBucks * rate\t\t// Money: 2360 JPY\r\n```\r\n\r\n### Money Context\r\nA MoneyContext can be implicitly declared to define default settings and applicable exchange rates within its scope.\r\nThis allows your application to work with a default currency based on an application configuration or other dynamic source.\r\nIt also provides support for updating exchange rates and using those rates for automatic conversions between currencies.\r\nThe technique and frequency chosen for exchange rate updates is completely in control of the application.\r\n\r\n```scala\r\nval exchangeRates = List(USD / CAD(1.05), USD / MXN(12.50), USD / JPY(100))\r\nimplicit val moneyContext = defaultMoneyContext withExchangeRates exchangeRates\r\n\r\nval someMoney = Money(350) // 350 in the default Cur\r\nval usdMoney: Money = someMoney in USD\r\nval usdBigDecimal: BigDecimal = someMoney to USD\r\nval yenCost: Money = (energyPrice * MegawattHours(5)) in JPY\r\nval northAmericanSales: Money = (CAD(275) + USD(350) + MXN(290)) in USD\r\n```\r\n\r\n## Quantity Ranges\r\nUsed to represent a range of Quantity values between an upper and lower bound\r\n\r\n```scala\r\nval load1: Power = Kilowatts(1000)\r\nval load2: Power = Kilowatts(5000)\r\nval range: QuantityRange[Power] = QuantityRange(load1, load2)\r\n```\r\n\r\nUse multiplication and division to create a Seq of ranges from the original\r\n\r\n```scala\r\n// Create a Seq of 10 sequential ranges starting with the original and each the same size as the original\r\nval rs1 = range * 10\r\n// Create a Seq of 10 sequential ranges each 1/10th of the original size\r\nval rs2 = range / 10\r\n// Create a Seq of 10 sequential ranges each with a size of 400 kilowatts\r\nval rs3 = range / Kilowatts(400)\r\n```\r\nApply foreach, map and foldLeft/foldRight directly to QuantityRanges with a divisor\r\n\r\n```scala\r\n// foreach over each of the 400 kilometer ranges within the range\r\nrange.foreach(Kilometers(400)) {r => ???}\r\n// map over each of 10 even parts of the range\r\nrange.map(10) {r => ???}\r\n// fold over each 10 even parts of the range\r\nrange.foldLeft(10)(0) {(z, r) => ???}\r\n```\r\n\r\nNOTE - Because these implementations of foreach, map and fold* take a parameter (the divisor), these methods\r\nare not directly compatible with Scala's for comprehensions. \r\nTo use in a for comprehension, apply the * or / operators as described above to create a Seq from the Range.\r\n\r\n```scala\r\nfor {\r\n    interval <- (0.seconds to 1.seconds) * 60  // 60 time ranges, 0s to 1s, 1s to 2s, ...., 59s to 60s\r\n    ...\r\n} yield ...\r\n```\r\n\r\n## Natural Language DSL\r\nImplicit conversions give the DSL some features that allows user code to express quantities in a\r\nmore naturally expressive and readable way.\r\n\r\nCreate Quantities using Unit Of Measure Factory objects (no implicits required)\r\n\r\n```scala\r\nval load = Kilowatts(100)\r\nval time = Hours(3.75)\r\nval money = USD(112.50)\r\nval price = Price(money, MegawattHours(1))\r\n```\r\n\r\nCreate Quantities using Unit of Measure names and/or symbols (uses implicits)\r\n\r\n```scala\r\nval load1 = 100 kW \t\t\t        // Simple expressions don’t need dots\r\nval load2 = 100 megaWatts\r\nval time = 3.hours + 45.minutes     // Compound expressions may need dots\r\n```\r\n\r\nCreate Quantities using operations between other Quantities\r\n\r\n```scala\r\nval energyUsed = 100.kilowatts * (3.hours + 45.minutes)\r\nval price = 112.50.USD / 1.megawattHours\r\nval speed = 55.miles / 1.hours\r\n```\r\n\r\nCreate Quantities using formatted Strings\r\n\r\n```scala\r\nval load = Power(\"40 MW\")\t\t// 40 MW\r\n```\r\n\r\nCreate Quantities using Tuples\r\n\r\n```scala\r\nval load = Power((40, \"MW\"))    // 40 MW\r\n```\r\n\r\nUse single unit values to simplify expressions\r\n\r\n```scala\r\n// Hours(1) == 1.hours == hour\r\nval ramp = 100.kilowatts / hour\r\nval speed = 100.kilometers / hour\r\n\r\n// MegawattHours(1) == 1.megawattHours == megawattHour == MWh\r\nval hi = 100.dollars / MWh\r\nval low = 40.dollars / megawattHour\r\n```\r\n\r\nImplicit conversion support for using Double on the left side of operations\r\n\r\n```scala\r\nval price = 10 / dollar\t    // 1 USD / 10 ea\r\nval freq = 60 / second\t    // 60 Hz\r\nval load = 10 * 4.MW\t\t// 40 MW\r\n```\r\n\r\nCreate Quantity Ranges using `to` or `plusOrMinus` (`+-`) operators\r\n\r\n```scala\r\nval range1 = 1000.kW to 5000.kW\t             // 1000.kW to 5000.kW\r\nval range2 = 5000.kW plusOrMinus 1000.kW     // 4000.kW to 6000.kW\r\nval range2 = 5000.kW +- 1000.kW              // 4000.kW to 6000.kW\r\n```\r\n\r\n### Numeric Support\r\nMost Quantities that support implicit conversions also include an implicit Numeric object that can be imported\r\nto your code where Numeric support is required.  These follow the following pattern:\r\n\r\n```scala\r\nimport squants.mass.MassConversions.MassNumeric\r\n\r\nval sum = List(Kilograms(100), Grams(34510)).sum\r\n```\r\n\r\nNOTE - Because a quantity can not be multiplied by a like quantity and return a like quantity, the `Numeric.times`\r\noperation of numeric is implemented to throw an UnsupportedOperationException for all types except `Dimensionless`.\r\n\r\nThe MoneyNumeric implementation is a bit different than the implementations for other quantity types\r\nin a few important ways.\r\n\r\n1. MoneyNumeric is a class, not an object like the others.\r\n2. To create a MoneyNumeric value there must be an implicit MoneyContext in scope.\r\n3. The MoneyContext must contain applicable exchange rates if you will be applying cross-currency Numeric ops.\r\n\r\nThe following code provides a basic example for creating a MoneyNumeric:\r\n\r\n```scala\r\nimport MoneyConversions._\r\nimplicit val moneyContext = defaultMoneyContext\r\nimplicit val moneyNum = new MoneyNumeric()\r\n\r\nval sum = List(USD(100), USD(10)).sum\r\n```\r\n\r\n## Type Hierarchy\r\nThe type hierarchy includes the following core types:  Quantity, Dimension, and UnitOfMeasure\r\n\r\n### Quantity and Dimension\r\n\r\nA Dimension represents a type of Quantity. For example: Mass, Length, Time, etc.\r\n\r\nA Quantity represents a dimensional value or measurement.  A Quantity is a combination of a numeric value and a unit.\r\nFor example:  2 lb, 10 km, 3.4 hr.\r\n\r\nSquants has built in support for 54 quantity dimensions.\r\n\r\n### Unit of Measure\r\nUnitOfMeasure is the scale or multiplier in which the Quantity is being measured.\r\nSquants has built in support for over 257 units of measure\r\n\r\nFor each Dimension a set of UOM objects implement a primary UOM trait typed to that Quantity.\r\nThe UOM objects define the unit symbols, conversion factors, and factory methods for creating Quantities in that unit.\r\n\r\n### Quantity Implementations\r\n\r\nThe code for specific implementations include\r\n\r\n* A class representing the Quantity including cross-dimensional operations\r\n* A companion object representing the Dimension and set of available units\r\n* A base trait for its Units\r\n* A set of objects defining specific units, their symbols and conversion factors\r\n\r\nThis is an abbreviated example of how a Quantity type is constructed:\r\n\r\n```scala\r\nclass Length(val value: Double, val unit: LengthUnit) extends Quantity[Length]  { ... }\r\nobject Length extends Dimension[Length]  { ... }\r\ntrait LengthUnit extends UnitOfMeasure[Length]  { ... }\r\nobject Meters extends LengthUnit { ... }\r\nobject Yards extends LengthUnit { ... }\r\n```\r\n\r\nThe apply method of the UOM objects are implemented as factories for creating Quantity values.\r\n\r\n```scala\r\nval len1: Length = Meters(4.3)\r\nval len2: Length = Yards(5)\r\n```\r\n\r\nSquants currently supports 257 units of measure\r\n\r\n### Time Derivatives\r\n\r\nSpecial traits are used to establish a time derivative relationship between quantities.\r\n\r\nFor example Velocity is the 1st Time Derivative of Length (Distance), Acceleration is the 2nd Time Derivative.\r\n\r\n```scala\r\nclass Length( ... ) extends Quantity[Length] with TimeIntegral[Velocity]\r\n...\r\nclass Velocity( ... ) extends Quantity[Velocity] with TimeDerivative[Length] with TimeIntegral[Acceleration]\r\n...\r\nclass Acceleration( ... ) extends Quantity[Acceleration] with TimeDerivative[Velocity]\r\n```\r\n\r\nThese traits provide operations with time operands which result in correct dimensional transformations.\r\n\r\n```scala\r\nval distance: Length = Kilometers(100)\r\nval time: Time = Hours(2)\r\nval velocity: Velocity = distance / time\r\nval acc: Acceleration = velocity / Seconds(1)\r\n\r\nval gravity = 32.feet / second.squared\r\n```\r\n\r\n```scala\r\n// Power is the 1st Time Derivative of Energy, PowerRamp is the 2nd\r\nval power = Kilowatts(100)\r\nval time: Time = Hours(2)\r\nval energy = power * time\r\nval ramp = Kilowatt(50) / Hours(1)\r\n```\r\n\r\n## Use Cases\r\n\r\n### Dimensional Analysis\r\n\r\nThe primary use case for Squants, as described above, is to produce code that is typesafe within domains\r\nthat perform dimensional analysis.\r\n\r\n```scala\r\nval energyPrice: Price[Energy] = 45.25.money / megawattHour\r\nval energyUsage: Energy = 345.kilowatts * 5.4.hours\r\nval energyCost: Money = energyPrice * energyUsage\r\n\r\nval dodgeViper: Acceleration = 60.miles / hour / 3.9.seconds\r\nval speedAfter5Seconds: Velocity = dodgeViper * 5.seconds\r\nval timeTo100MPH: Time = 100.miles / hour / dodgeViper\r\n\r\nval density: Density = 1200.kilograms / cubicMeter\r\nval volFlowRate: VolumeFlowRate = 10.gallons / minute\r\nval flowTime: Time = 30.minutes\r\nval totalMassFlow: Mass = volFlowRate * flowTime * density\r\n```\r\n\r\n### Domain Modeling\r\nAnother excellent use case for Squants is stronger typing for fields in your domain model.\r\nThis is OK ...\r\n\r\n```scala\r\ncase class Generator(\r\n  id: String,\r\n  maxLoadKW: Double,\r\n  rampRateKWph: Double,\r\n  operatingCostPerMWh: Double,\r\n  currency: String,\r\n  maintenanceTimeHours: Double)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5000, 7500, 75.4, \"USD\", 1.5)\r\nval gen2 = Generator(\"Gen2\", 100, 250, 2944.5, \"JPY\", 0.5)\r\n```\r\n\r\n... but this is much better\r\n\r\n```scala\r\ncase class Generator(\r\n  id: String,\r\n  maxLoad: Power,\r\n  rampRate: PowerRamp,\r\n  operatingCost: Price[Energy],\r\n  maintenanceTime: Time)\r\n...\r\nval gen1 = Generator(\"Gen1\", 5 MW, 7.5.MW/hour, 75.4.USD/MWh, 1.5 hours)\r\nval gen2 = Generator(\"Gen2\", 100 kW, 250 kWph, 2944.5.JPY/MWh, 30 minutes)\r\n```\r\n\r\n### Anticorruption Layers\r\n\r\nCreate wrappers around external services that use basic types to represent quantities.\r\nYour application code then uses the ACL to communicate with that system thus eliminating the need to deal\r\nwith type and scale conversions in multiple places throughout your application logic.\r\n\r\n```scala\r\nclass ScadaServiceAnticorruption(val service: ScadaService) {\r\n  // ScadaService returns meter load as Double representing Megawatts\r\n  def getLoad: Power = Megawatts(service.getLoad(meterId))\r\n  }\r\n  // ScadaService.sendTempBias requires a Double representing Fahrenheit\r\n  def sendTempBias(temp: Temperature) =\r\n    service.sendTempBias(temp.to(Fahrenheit))\r\n}\r\n```\r\n\r\nImplement the ACL as a trait and mix in to the application's services where needed.\r\n\r\n```scala\r\ntrait WeatherServiceAntiCorruption {\r\n  val service: WeatherService\r\n  def getTemperature: Temperature = Celsius(service.getTemperature)\r\n  def getIrradiance: Irradiance = WattsPerSquareMeter(service.getIrradiance)\r\n}\r\n```\r\n\r\nExtend the pattern to provide multi-currency support\r\n\r\n```scala\r\nclass MarketServiceAnticorruption(val service: MarketService)\r\n     (implicit val moneyContext: = MoneyContext) {\r\n\r\n  // MarketService.getPrice returns a Double representing $/MegawattHour\r\n  def getPrice: Price[Energy] =\r\n    (USD(service.getPrice) in moneyContext.defaultCurrency) / megawattHour\r\n\r\n  // MarketService.sendBid requires a Double representing $/MegawattHour\r\n  // and another Double representing the max amount of energy in MegawattHours\r\n  def sendBid(bid: Price[Energy], limit: Energy) =\r\n    service.sendBid((bid * megawattHour) to USD, limit to MegawattHours)\r\n}\r\n```\r\n\r\nBuild Anticorruption into Akka routers\r\n\r\n```scala\r\n// LoadReading message used within a Squants enabled application context\r\ncase class LoadReading(meterId: String, time: Long, load: Power)\r\nclass ScadaLoadListener(router: Router) extends Actor {\r\n  def receive = {\r\n   // ScadaLoadReading - from an external service - sends load as a string\r\n   // eg, “10.3 MW”, “345 kW”\r\n   case msg @ ScadaLoadReading(meterId, time, loadString) ⇒\r\n    // Parse the string and on success emit the Squants enabled event to routees\r\n    Power(loadString) match {\r\n      case Success(p) => router.route(LoadReading(meterId, time, p), sender())\r\n      case Failure(e) => // react to QuantityStringParseException\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n... and REST API's with contracts that require basic types\r\n\r\n```scala\r\ntrait LoadRoute extends HttpService {\r\n  def repo: LoadRepository\r\n  val loadRoute = {\r\n    path(\"meter-reading\") {\r\n      // REST API contract requires load value and units in different fields\r\n      // Units are string values that may be 'kW' or 'MW'\r\n      post {\r\n        parameters(meterId, time, loadDouble, unit) { (meterId, time, loadDouble, unit) =>\r\n          complete {\r\n            val load = unit match {\r\n              case \"kW\" => Kilowatts(loadDouble)\r\n              case \"MW\" => Megawatts(loadDouble)\r\n            }\r\n            repo.saveLoad(meterId, time, load)\r\n          }\r\n        }\r\n      } ~\r\n      // REST API contract requires load returned as a number representing megawatts\r\n      get {\r\n        parameters(meterId, time) { (meterId, time) =>\r\n          complete {\r\n            repo.getLoad(meterId, time) to Megawatts\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Contributors\r\n\r\n* Gary Keorkunian ([garyKeorkunian](https://github.com/garyKeorkunian))\r\n* Jeremy Apthorp ([nornagon](https://github.com/nornagon))\r\n* Steve Barham ([stevebarham](https://github.com/stevebarham))\r\n* Derek Morr ([derekmorr](https://github.com/derekmorr))\r\n* rmihael ([rmihael](https://github.com/rmihael))\r\n* Florian Nussberger ([fnussber](https://github.com/fnussber))\r\n\r\n## Caveats\r\n\r\nCode is offered as-is, with no implied warranty of any kind.\r\nComments, criticisms, and/or praise are welcome, especially from scientists, engineers and the like.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}